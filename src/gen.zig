const std = @import("std");
const muvarint = @import("muvarint");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    // Open the CSV file for reading
    const input_file = try std.fs.cwd().openFile("table.csv", .{ .mode = std.fs.File.OpenMode.read_only });
    defer input_file.close();

    // Read all data from the CSV file
    const csv_data = try input_file.readToEndAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(csv_data);

    // Open the output file for writing
    const output_file = try std.fs.cwd().createFile("src/table.zig", .{});
    defer output_file.close();

    // Start writing the Zig file content
    try output_file.writeAll(
        \\// DO NOT CHANGE THIS FILE. IT IS GENERATED BY src/gen.zig
        \\
        \\const std = @import("std");
        \\pub const Status = enum { Permanent, Draft, Deprecated };
        \\pub const Multicodec = struct {
        \\    name: []const u8,
        \\    tag: []const u8,
        \\    code: u32,
        \\    status: Status,
        \\    description: ?[]const u8,
        \\};
        \\
        \\
        \\pub const multicodecTable = std.StaticStringMap(Multicodec).initComptime(.{
        \\
    );

    // Split CSV data by line
    var lines = std.mem.tokenize(u8, csv_data, "\n");

    {
        // Skip the header
        _ = lines.next();

        while (lines.next()) |line| {
            var fields = std.mem.tokenize(u8, line, ",");

            const name = std.mem.trim(u8, fields.next() orelse break, " ");
            const tag = std.mem.trim(u8, fields.next() orelse break, " ");
            const code = std.mem.trim(u8, fields.next() orelse break, " ");
            const status_str = std.mem.trim(u8, fields.next() orelse break, " ");
            const description = fields.next() orelse null;

            const status = blk: {
                if (std.mem.eql(u8, status_str, "permanent")) break :blk "Status.Permanent";
                if (std.mem.eql(u8, status_str, "draft")) break :blk "Status.Draft";
                if (std.mem.eql(u8, status_str, "deprecated")) break :blk "Status.Deprecated";
                @panic("unknown status string");
            };

            const name_replaced = try allocator.dupe(u8, name);
            std.mem.replaceScalar(u8, name_replaced, '-', '_');

            const string = try std.fmt.allocPrint(
                allocator,
                ".{{\"{s}\", .{{ .name = \"{s}\", .tag = \"{s}\", .code = {s}, .status = {s}, .description = \"{?s}\" }} }},\n",
                .{
                    name_replaced,
                    name,
                    tag,
                    code,
                    status,
                    description,
                },
            );
            defer allocator.free(string);

            try output_file.writeAll(string);
        }
        try output_file.writeAll("});\n\n");
    }

    // Codecs
    try output_file.writeAll(
        \\pub const Codec = enum(u32) {
        \\
    );

    lines.reset();
    {
        // Skip the header
        _ = lines.next();

        while (lines.next()) |line| {
            var fields = std.mem.tokenize(u8, line, ",");

            const name = std.mem.trim(u8, fields.next() orelse break, " ");
            _ = std.mem.trim(u8, fields.next() orelse break, " ");
            const code = std.mem.trim(u8, fields.next() orelse break, " ");

            const name_replaced = try allocator.dupe(u8, name);
            std.mem.replaceScalar(u8, name_replaced, '-', '_');

            const string = try std.fmt.allocPrint(
                allocator,
                "{s} = {s},\n",
                .{ name_replaced, code },
            );
            defer allocator.free(string);

            try output_file.writeAll(string);
        }
        try output_file.writeAll("};\n\n");
    }
}
